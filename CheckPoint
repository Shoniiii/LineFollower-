#include <Arduino.h>
#include <U8glib.h>
#include <EEPROM.h>

// ============================ KONFIGURASI PIN ============================
// Tombol (sesuai Wokwi JSON + fungsi)
#define BTN_CALIB_PIN 11 // tombol kalibrasi sensor + BACK (kiri atas)
#define BTN_CHECK_PIN 12 // tombol cek sensor / +PID (kiri bawah)
#define BTN_START_PIN 7  // tombol START/STOP / NEXT PID (kanan bawah)
#define BTN_EXTRA_PIN 8  // tombol CALIB PID / EXIT PID (kanan atas)

// 4051 multiplexer
const int selectPins[3] = {2, 3, 4}; // S0->2, S1->3, S2->4
const int zInput = A0;               // Z common -> A0

// Motor H-Bridge: 4 kanal PWM terpisah
const int Motor_R_PWM_FWD = 5;
const int Motor_R_PWM_BWD = 6;
const int Motor_L_PWM_FWD = 9;
const int Motor_L_PWM_BWD = 10;

// Kecepatan dasar (bisa diatur / dituning)
int PWM_Speed = 50;

// PID sebagai float (bisa 0.1 step)
float Kp = 2.5;
float Ki = 0.0;
float Kd = 2.0;

// ============================ CHECKPOINT CONFIGURATION ============================
// Maksimal 30 checkpoint (seperti maxplan 30)
#define MAX_CHECKPOINTS 30

// Struktur untuk checkpoint (seperti pattern tapi dengan AND trigger dan action type)
struct Checkpoint
{
  byte sensor_mask; // bitmask sensor (AND: semua bit harus HIGH untuk trigger)
  int duration_ms;  // waktu/durasi action dalam ms
  byte action_type; // 0: belok kiri, 1: belok kanan, 2: berhenti (stop), 3: forward, 4: U-turn
  bool enabled;     // checkpoint aktif atau tidak
};

// Array untuk 30 checkpoint
Checkpoint checkpoints[MAX_CHECKPOINTS];

// Checkpoint saat ini dalam sequence
byte current_checkpoint = 0;

// EEPROM address offset untuk checkpoints (mulai dari address 16, setiap checkpoint 5 bytes:
// mask(1), duration(2), type(1), enabled(1) = 5 bytes * 30 = 150 bytes)
#define CHECKPOINT_EEPROM_START 16

// Mode menu checkpoint
bool checkpoint_config_mode = false;
byte checkpoint_menu_index = 0; // checkpoint mana yang sedang diedit (0-29)
byte checkpoint_edit_field = 0; // field mana yang sedang diedit (0=sensor_mask, 1=duration, 2=action_type, 3=enabled)

// Submode untuk edit sensor_mask (bit by bit)
bool sensor_mask_edit_mode = false;
byte sensor_bit_pos = 0; // posisi bit sensor (0-7) yang sedang diedit

// ============================ VARIABEL LOGIKA ============================
int Sensor_ADC_0[8];
bool bit_Sensor[8];
byte bin_Sensor = 0b00000000;
int HighRef[8];
int LowRef[8];
int ResultRef[8];
bool calibration_mode = false;
bool sensor_check_mode = false;
bool start_mode = false;
bool pid_calib_mode = false;
int calibration_process = 1;
int error = 0, last_error = 0;
float I_accum = 0.0f;
byte pid_param_index = 0;
int last_PWM_cmd_L = 0;
int last_PWM_cmd_R = 0;

// State untuk action (belok atau berhenti)
bool is_acting = false;
unsigned long action_start_time = 0;
int current_action_duration = 0;
byte current_action_type = 0; // 0=left, 1=right, 2=stop, 3=forward, 4=U-turn

// ============================ DISPLAY ============================
U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE | U8G_I2C_OPT_DEV_0);

// ============================ PROTOTYPE FUNGSI ============================
bool btnCalib();
bool btnCheck();
bool btnStart();
bool btnExtra();
void showMainMenu();
void showPidCalibScreen();
void showCheckpointConfigScreen();
void check_Error();
void right_Forward(int pwm);
void right_Backward(int pwm);
void left_Forward(int pwm);
void left_Backward(int pwm);
void stop_Right();
void stop_Left();
void stop_Both();
void turn_Right(int pwm);
void turn_Left(int pwm);
void forward_Both(int pwm);  // NEW
void uturn_Right(int pwm);   // NEW
bool check_Checkpoint_Trigger();
void calibration();
void check_Sensor();
void read_Sensor();
void selectMultiplexerPin(byte pin);
void printBinaryByte(byte value);
void writeIntIntoEEPROM(int index, int number);
int readIntFromEEPROM(int index);
void saveCheckpoints();
void loadCheckpoints();
void initDefaultCheckpoints();

// ============================ SETUP ============================
void setup()
{
  // Pin multiplexer sebagai output, default HIGH
  for (int i = 0; i < 3; i++)
  {
    pinMode(selectPins[i], OUTPUT);
    digitalWrite(selectPins[i], HIGH);
  }

  // Tombol (INPUT_PULLUP)
  pinMode(BTN_CALIB_PIN, INPUT_PULLUP);
  pinMode(BTN_CHECK_PIN, INPUT_PULLUP);
  pinMode(BTN_START_PIN, INPUT_PULLUP);
  pinMode(BTN_EXTRA_PIN, INPUT_PULLUP);

  // Motor PWM
  pinMode(Motor_R_PWM_FWD, OUTPUT);
  pinMode(Motor_R_PWM_BWD, OUTPUT);
  pinMode(Motor_L_PWM_FWD, OUTPUT);
  pinMode(Motor_L_PWM_BWD, OUTPUT);

  // Semua motor off dulu
  stop_Right();
  stop_Left();

  // Ambil nilai kalibrasi sensor dari EEPROM
  for (byte i = 0; i <= 7; i++)
  {
    ResultRef[i] = readIntFromEEPROM(i);
  }

  // Load checkpoints dari EEPROM
  loadCheckpoints();
  u8g.setFont(u8g_font_unifont);

  // Splash
  u8g.firstPage();
  do
  {
    u8g.setPrintPos(12, 14);
    u8g.print("LINE FOLLOWER");
    u8g.setPrintPos(43, 29);
    u8g.print("ROBOT");
    u8g.setPrintPos(55, 44);
    u8g.print("BY");
    u8g.setPrintPos(23, 59);
    u8g.print("PENS EEPIS");
  } while (u8g.nextPage());
  delay(1000);

  // INIT ACTUATOR
  u8g.firstPage();
  do
  {
    u8g.setPrintPos(0, 14);
    u8g.print("INIT ACTUATOR");
  } while (u8g.nextPage());
  right_Forward(150);
  left_Forward(150);
  delay(800);
  stop_Right();
  stop_Left();
  delay(400);
}

// ============================ LOOP ============================
void loop()
{
  // ==== MODE KONFIGURASI CHECKPOINT ====
  if (checkpoint_config_mode)
  {
    showCheckpointConfigScreen();
    // Jika di submode edit sensor_mask
    if (sensor_mask_edit_mode)
    {
      // BTN CALIB: pindah bit ke kiri (decrease pos)
      if (btnCalib() == LOW)
      {
        sensor_bit_pos = (sensor_bit_pos == 0) ? 7 : sensor_bit_pos - 1;
        delay(150);
      }

      // BTN CHECK: toggle bit di posisi saat ini
      if (btnCheck() == LOW)
      {
        checkpoints[checkpoint_menu_index].sensor_mask ^= (1 << sensor_bit_pos);
        delay(150);
      }

      // BTN START: keluar submode
      if (btnStart() == LOW)
      {
        sensor_mask_edit_mode = false;
        while (btnStart() == LOW)
        {
          delay(50);
        }
      }
      return;
    }

    // BTN CALIB: kurangi nilai field aktif (kiri atas)
    if (btnCalib() == LOW)
    {
      if (checkpoint_edit_field == 0)
      {
        sensor_mask_edit_mode = true; // masuk submode edit mask
      }
      else if (checkpoint_edit_field == 1)
      { // duration
        checkpoints[checkpoint_menu_index].duration_ms -= 50;
        if (checkpoints[checkpoint_menu_index].duration_ms < 100)
          checkpoints[checkpoint_menu_index].duration_ms = 100;
      }
      else if (checkpoint_edit_field == 2)
      { // action_type (decrement circular 0..4)
        if (checkpoints[checkpoint_menu_index].action_type == 0)
          checkpoints[checkpoint_menu_index].action_type = 4;
        else
          checkpoints[checkpoint_menu_index].action_type--;
      }
      else if (checkpoint_edit_field == 3)
      { // enabled
        checkpoints[checkpoint_menu_index].enabled = !checkpoints[checkpoint_menu_index].enabled;
      }
      delay(150);
    }

    // BTN CHECK: tambah nilai field aktif (kiri bawah)
    if (btnCheck() == LOW)
    {
      if (checkpoint_edit_field == 0)
      {
        sensor_mask_edit_mode = true; // masuk submode edit mask
      }
      else if (checkpoint_edit_field == 1)
      { // duration
        checkpoints[checkpoint_menu_index].duration_ms += 50;
        if (checkpoints[checkpoint_menu_index].duration_ms > 3000)
          checkpoints[checkpoint_menu_index].duration_ms = 3000;
      }
      else if (checkpoint_edit_field == 2)
      { // action_type (increment 0..4)
        checkpoints[checkpoint_menu_index].action_type = (checkpoints[checkpoint_menu_index].action_type + 1) % 5;
      }
      else if (checkpoint_edit_field == 3)
      { // enabled
        checkpoints[checkpoint_menu_index].enabled = !checkpoints[checkpoint_menu_index].enabled;
      }
      delay(150);
    }

    // BTN START: pindah field atau checkpoint berikutnya (kanan bawah)
    if (btnStart() == LOW)
    {
      checkpoint_edit_field++;
      if (checkpoint_edit_field > 3)
      {
        checkpoint_edit_field = 0;
        checkpoint_menu_index = (checkpoint_menu_index + 1) % MAX_CHECKPOINTS;
      }
      while (btnStart() == LOW)
      {
        delay(50);
      }
    }

    // BTN EXTRA: simpan dan keluar (kanan atas)
    if (btnExtra() == LOW)
    {
      saveCheckpoints();
      checkpoint_config_mode = false;
      u8g.firstPage();
      do
      {
        u8g.setPrintPos(10, 32);
        u8g.print("CHECKPOINT SAVED!");
      } while (u8g.nextPage());
      delay(800);
      while (btnExtra() == LOW)
      {
        delay(50);
      }
    }
    return;
  }

  // ==== MODE KALIBRASI PID ====
  if (pid_calib_mode)
  {
    showPidCalibScreen();
    if (btnCalib() == LOW)
    {
      if (pid_param_index == 0)
        Kp -= 0.1f;
      if (pid_param_index == 1)
        Ki -= 0.1f;
      if (pid_param_index == 2)
        Kd -= 0.1f;
      if (pid_param_index == 3)
        PWM_Speed -= 5;
      if (Kp < 0)
        Kp = 0;
      if (Ki < 0)
        Ki = 0;
      if (Kd < 0)
        Kd = 0;
      if (PWM_Speed < 0)
        PWM_Speed = 0;
      delay(150);
    }
    if (btnCheck() == LOW)
    {
      if (pid_param_index == 0)
        Kp += 0.1f;
      if (pid_param_index == 1)
        Ki += 0.1f;
      if (pid_param_index == 2)
        Kd += 0.1f;
      if (pid_param_index == 3)
        PWM_Speed += 5;
      if (PWM_Speed > 255)
        PWM_Speed = 255;
      delay(150);
    }
    if (btnStart() == LOW)
    {
      pid_param_index = (pid_param_index + 1) % 4; // hilangkan PT karena diganti checkpoint sequence
      while (btnStart() == LOW)
      {
        delay(50);
      }
    }
    if (btnExtra() == LOW)
    {
      pid_calib_mode = false;
      while (btnExtra() == LOW)
      {
        delay(50);
      }
    }
    return;
  }

  // ==== TAMPILKAN MENU UTAMA ====
  if (start_mode == false && !calibration_mode && !sensor_check_mode)
  {
    showMainMenu();
  }
  // ==== 1. KALIBRASI SENSOR (BTN CALIB) ====
  if (btnCalib() == LOW && start_mode == false && !calibration_mode && !sensor_check_mode)
  {
    calibration_mode = true;
    while (btnCalib() == LOW)
    {
      delay(100);
    }
    calibration();
  }
  // ==== 2. KALIBRASI PID (BTN EXTRA) ====
  if (btnExtra() == LOW && start_mode == false && !calibration_mode && !sensor_check_mode)
  {
    pid_calib_mode = true;
    pid_param_index = 0;
    while (btnExtra() == LOW)
    {
      delay(100);
    }
  }
  // ==== 3. MODE CEK SENSOR (BTN CHECK) ====
  if (btnCheck() == LOW && start_mode == false && !sensor_check_mode && !calibration_mode)
  {
    sensor_check_mode = true;
    while (btnCheck() == LOW)
    {
      delay(100);
    }
    while (sensor_check_mode == true)
    {
      check_Sensor();
      u8g.firstPage();
      do
      {
        u8g.setPrintPos(0, 10);
        u8g.print("CHECK STATUS");
        u8g.setPrintPos(0, 22);
        printBinaryByte(bin_Sensor);
        u8g.setPrintPos(0, 34);
        u8g.print("Kp:");
        u8g.print(Kp, 1);
        u8g.setPrintPos(64, 34);
        u8g.print("Ki:");
        u8g.print(Ki, 1);
        u8g.setPrintPos(0, 46);
        u8g.print("Kd:");
        u8g.print(Kd, 1);
        u8g.setPrintPos(0, 58);
        u8g.print("P:");
        u8g.print(PWM_Speed);
        u8g.setPrintPos(50, 58);
        u8g.print("L:");
        u8g.print(last_PWM_cmd_L);
        u8g.setPrintPos(90, 58);
        u8g.print("R:");
        u8g.print(last_PWM_cmd_R);
      } while (u8g.nextPage());
      if (btnCalib() == LOW)
      {
        sensor_check_mode = false;
        while (btnCalib() == LOW)
        {
          delay(100);
        }
      }

      // Tekan BTN_EXTRA untuk masuk ke checkpoint config
      if (btnExtra() == LOW)
      {
        sensor_check_mode = false;
        checkpoint_config_mode = true;
        checkpoint_menu_index = 0;
        checkpoint_edit_field = 0;
        while (btnExtra() == LOW)
        {
          delay(100);
        }
      }
      delay(10);
    }
  }

  // ==== 4. START / STOP (BTN START) ====
  if (btnStart() == LOW && !calibration_mode && !sensor_check_mode)
  {
    start_mode = !start_mode;
    while (btnStart() == LOW)
    {
      delay(100);
    }
    if (start_mode == true)
    {
      u8g.firstPage();
      do
      {
        u8g.setPrintPos(5, 29);
        u8g.print("...RUNNING...");
        u8g.setPrintPos(0, 59);
        u8g.print("4. STOP");
      } while (u8g.nextPage());
      is_acting = false;
      I_accum = 0.0f;
      last_error = 0;
      current_checkpoint = 0; // reset ke checkpoint pertama saat start
    }
    else
    {
      stop_Right();
      stop_Left();
      is_acting = false;
    }
  }

  // ==================== PID CONTROLLER + CHECKPOINT ACTION ====================
  if (start_mode == true)
  {
    // Cek apakah sedang dalam proses action (belok/berhenti/forward/U-turn)
    if (is_acting)
    {
      if (millis() - action_start_time >= current_action_duration)
      {
        is_acting = false;
        I_accum = 0.0f;
        last_error = 0;
        stop_Both(); // stop setelah action selesai
      }
      else
      {
        // Lakukan action sesuai type
        if (current_action_type == 1)
        {
          turn_Right(PWM_Speed);
        }
        else if (current_action_type == 0)
        {
          turn_Left(PWM_Speed);
        }
        else if (current_action_type == 2)
        {
          stop_Both();
        }
        else if (current_action_type == 3)
        {
          forward_Both(PWM_Speed);
        }
        else if (current_action_type == 4)
        {
          uturn_Right(PWM_Speed);
        }
        return;
      }
    }

    // Cek trigger checkpoint saat ini
    if (!is_acting && check_Checkpoint_Trigger())
    {
      is_acting = true;
      action_start_time = millis();
      current_action_duration = checkpoints[current_checkpoint].duration_ms;
      current_action_type = checkpoints[current_checkpoint].action_type;

      // Increment ke checkpoint berikutnya jika enabled
      if (checkpoints[current_checkpoint].enabled)
      {
        current_checkpoint = (current_checkpoint + 1) % MAX_CHECKPOINTS;
      }

      // Mulai action
      if (current_action_type == 1)
      {
        turn_Right(PWM_Speed);
      }
      else if (current_action_type == 0)
      {
        turn_Left(PWM_Speed);
      }
      else if (current_action_type == 2)
      {
        stop_Both();
      }
      else if (current_action_type == 3)
      {
        forward_Both(PWM_Speed);
      }
      else if (current_action_type == 4)
      {
        uturn_Right(PWM_Speed);
      }
      return;
    }

    // ===== PID NORMAL (FOLLOW LINE) =====
    int PWM_Max_R = PWM_Speed;
    int PWM_Max_L = PWM_Speed;

    check_Error();

    float P = (float)error;
    I_accum += (float)error;

    if (I_accum > 1000.0f)
      I_accum = 1000.0f;

    if (I_accum < -1000.0f)
      I_accum = -1000.0f;

    float D = (float)(error - last_error);
    last_error = error;

    float PID = (Kp * P) + (Ki * I_accum) + (Kd * D);

    float PWM_R_f = (float)PWM_Max_R - PID;
    float PWM_L_f = (float)PWM_Max_L + PID;

    int pwmR_cmd = 0;
    int pwmL_cmd = 0;

    if (PWM_R_f >= 0)
    {
      pwmR_cmd = (int)constrain(PWM_R_f, 0, 255);
      right_Forward(pwmR_cmd);
    }
    else
    {
      pwmR_cmd = (int)constrain(-PWM_R_f, 0, 255);
      right_Backward(pwmR_cmd);
    }

    if (PWM_L_f >= 0)
    {
      pwmL_cmd = (int)constrain(PWM_L_f, 0, 255);
      left_Forward(pwmL_cmd);
    }
    else
    {
      pwmL_cmd = (int)constrain(-PWM_L_f, 0, 255);
      left_Backward(pwmL_cmd);
    }

    last_PWM_cmd_R = pwmR_cmd;
    last_PWM_cmd_L = pwmL_cmd;
  }
}

// ============================ UTILITAS TOMBOL ============================
bool btnCalib()
{
  return digitalRead(BTN_CALIB_PIN);
}
bool btnCheck()
{
  return digitalRead(BTN_CHECK_PIN);
}
bool btnStart()
{
  return digitalRead(BTN_START_PIN);
}
bool btnExtra()
{
  return digitalRead(BTN_EXTRA_PIN);
}

// ============================ MENU & DISPLAY ============================
void showMainMenu()
{
  u8g.firstPage();
  do
  {
    u8g.setPrintPos(40, 10);
    u8g.print("MAIN MENU");
    u8g.setPrintPos(0, 25);
    u8g.print("1. CALIB SENSOR");
    u8g.setPrintPos(0, 38);
    u8g.print("2. CALIB PID");
    u8g.setPrintPos(0, 51);
    u8g.print("3. CHECK STATUS");
    u8g.setPrintPos(0, 64);
    u8g.print("4. START");
  } while (u8g.nextPage());
}

void showPidCalibScreen()
{
  u8g.firstPage();
  do
  {
    u8g.setPrintPos(25, 10);
    u8g.print("CALIB PID");
    u8g.setPrintPos(0, 23);

    if (pid_param_index == 0)
      u8g.print(">");
    else
      u8g.print(" ");
    u8g.print("Kp=");
    u8g.print(Kp, 1);
    u8g.setPrintPos(0, 35);

    if (pid_param_index == 1)
      u8g.print(">");
    else
      u8g.print(" ");
    u8g.print("Ki=");
    u8g.print(Ki, 1);
    u8g.setPrintPos(0, 47);

    if (pid_param_index == 2)
      u8g.print(">");
    else
      u8g.print(" ");
    u8g.print("Kd=");
    u8g.print(Kd, 1);
    u8g.setPrintPos(0, 59);

    if (pid_param_index == 3)
      u8g.print(">");
    else
      u8g.print(" ");
    u8g.print("PWM=");
    u8g.print(PWM_Speed);
  } while (u8g.nextPage());
}

void showCheckpointConfigScreen()
{
  u8g.firstPage();
  do
  {
    u8g.setPrintPos(0, 10);
    u8g.print("CHKPT ");
    u8g.print(checkpoint_menu_index);

    if (sensor_mask_edit_mode)
    {
      u8g.setPrintPos(0, 23);
      u8g.print("Mask Edit: ");
      printBinaryByte(checkpoints[checkpoint_menu_index].sensor_mask);
      u8g.setPrintPos(0, 35);
      u8g.print("Bit: ");
      u8g.print(sensor_bit_pos);
      u8g.setPrintPos(0, 47);
      u8g.print("CALIB: <- Bit");
      u8g.setPrintPos(0, 59);
      u8g.print("CHECK: Toggle");
    }

    else
    {
      u8g.setPrintPos(0, 23);

      if (checkpoint_edit_field == 0)
        u8g.print(">");
      else
        u8g.print(" ");
      u8g.print("Mask=");
      printBinaryByte(checkpoints[checkpoint_menu_index].sensor_mask);

      u8g.setPrintPos(0, 35);
      if (checkpoint_edit_field == 1)
        u8g.print(">");
      else
        u8g.print(" ");
      u8g.print("Time=");
      u8g.print(checkpoints[checkpoint_menu_index].duration_ms);

      u8g.setPrintPos(0, 47);
      if (checkpoint_edit_field == 2)
        u8g.print(">");
      else
        u8g.print(" ");
      u8g.print("Act=");

      if (checkpoints[checkpoint_menu_index].action_type == 0)
        u8g.print("L");
      else if (checkpoints[checkpoint_menu_index].action_type == 1)
        u8g.print("R");
      else if (checkpoints[checkpoint_menu_index].action_type == 2)
        u8g.print("S");
      else if (checkpoints[checkpoint_menu_index].action_type == 3)
        u8g.print("F");
      else if (checkpoints[checkpoint_menu_index].action_type == 4)
        u8g.print("U");

      u8g.setPrintPos(0, 59);
      if (checkpoint_edit_field == 3)
        u8g.print(">");
      else
        u8g.print(" ");
      u8g.print("En=");
      u8g.print(checkpoints[checkpoint_menu_index].enabled ? "Y" : "N");
    }
  } while (u8g.nextPage());
}

// ============================ PID & SENSOR ============================
// Fungsi cek trigger berdasarkan checkpoint saat ini
bool check_Checkpoint_Trigger()
{
  if (current_checkpoint >= MAX_CHECKPOINTS || !checkpoints[current_checkpoint].enabled)
    return false;

  check_Sensor();

  byte mask = checkpoints[current_checkpoint].sensor_mask;

  // Cek AND: semua bit di mask harus set di bin_Sensor
  if ((bin_Sensor & mask) == mask)
  {
    return true;
  }

  return false;
}

void check_Error()
{
  check_Sensor();
  if (bin_Sensor == 0b00011000) error = 0;
  else if (bin_Sensor == 0b00000001) error = 13;
  else if (bin_Sensor == 0b00000011) error = 11;
  else if (bin_Sensor == 0b00000010) error = 9;
  else if (bin_Sensor == 0b00000110) error = 7;
  else if (bin_Sensor == 0b00000100) error = 5;
  else if (bin_Sensor == 0b00001100) error = 3;
  else if (bin_Sensor == 0b00001000) error = 1;
  else if (bin_Sensor == 0b00010000) error = -1;
  else if (bin_Sensor == 0b00110000) error = -3;
  else if (bin_Sensor == 0b00100000) error = -5;
  else if (bin_Sensor == 0b01100000) error = -7;
  else if (bin_Sensor == 0b01000000) error = -9;
  else if (bin_Sensor == 0b11000000) error = -11;
  else if (bin_Sensor == 0b10000000) error = -13;
  else if (bin_Sensor == 0b01111110) error = -7;
}

// ===================== KENDALI MOTOR (4 PWM) =====================
void right_Forward(int pwm)
{
  pwm = constrain(pwm, 0, 255);
  analogWrite(Motor_R_PWM_FWD, pwm);
  analogWrite(Motor_R_PWM_BWD, 0);
}
void right_Backward(int pwm)
{
  pwm = constrain(pwm, 0, 255);
  analogWrite(Motor_R_PWM_FWD, 0);
  analogWrite(Motor_R_PWM_BWD, pwm);
}
void left_Forward(int pwm)
{
  pwm = constrain(pwm, 0, 255);
  analogWrite(Motor_L_PWM_FWD, 0);
  analogWrite(Motor_L_PWM_BWD, pwm);
}
void left_Backward(int pwm)
{
  pwm = constrain(pwm, 0, 255);
  analogWrite(Motor_L_PWM_FWD, pwm);
  analogWrite(Motor_L_PWM_BWD, 0);
}
void stop_Right()
{
  analogWrite(Motor_R_PWM_FWD, 0);
  analogWrite(Motor_R_PWM_BWD, 0);
}
void stop_Left()
{
  analogWrite(Motor_L_PWM_FWD, 0);
  analogWrite(Motor_L_PWM_BWD, 0);
}
void stop_Both()
{
  stop_Right();
  stop_Left();
  last_PWM_cmd_L = 0;
  last_PWM_cmd_R = 0;
}
void turn_Right(int pwm)
{
  pwm = constrain(pwm, 0, 255);
  left_Forward(pwm);
  right_Backward(pwm / 2);
  last_PWM_cmd_L = pwm;
  last_PWM_cmd_R = -pwm / 2;
}
void turn_Left(int pwm)
{
  pwm = constrain(pwm, 0, 255);
  right_Forward(pwm);
  left_Backward(pwm / 2);
  last_PWM_cmd_R = pwm;
  last_PWM_cmd_L = -pwm / 2;
}

// NEW: forward & U-turn
void forward_Both(int pwm)
{
  pwm = constrain(pwm, 0, 255);
  right_Forward(pwm);
  left_Forward(pwm);
  last_PWM_cmd_L = pwm;
  last_PWM_cmd_R = pwm;
}

void uturn_Right(int pwm)
{
  pwm = constrain(pwm, 0, 255);
  // Spin di tempat ke kanan: kiri maju, kanan mundur
  left_Forward(pwm);
  right_Backward(pwm);
  last_PWM_cmd_L = pwm;
  last_PWM_cmd_R = -pwm;
}

// ===================== KALIBRASI & SENSOR =====================
void calibration()
{
  calibration_process = 1;
  u8g.firstPage();
  do
  {
    u8g.setPrintPos(20, 29);
    u8g.print("CALIB SENSOR");
    u8g.setPrintPos(0, 59);
    u8g.print("1. Next/Done");
  } while (u8g.nextPage());
  for (byte i = 0; i <= 7; i++)
  {
    HighRef[i] = 0;
    LowRef[i] = 1023;
  }
  while (calibration_mode == true)
  {
    if (btnCalib() == LOW)
    {
      calibration_process++;
      while (btnCalib() == LOW)
      {
        delay(100);
      }
    }
    if (calibration_process == 1)
    {
      read_Sensor();
      for (byte i = 0; i <= 7; i++)
      {
        if (Sensor_ADC_0[i] > HighRef[i])
          HighRef[i] = Sensor_ADC_0[i];
        if (Sensor_ADC_0[i] < LowRef[i])
          LowRef[i] = Sensor_ADC_0[i];
        writeIntIntoEEPROM(i, ResultRef[i]);
      }
    }
    if (calibration_process == 2)
    {
      for (byte i = 0; i <= 7; i++)
      {
        ResultRef[i] = (HighRef[i] + LowRef[i]) / 2;
        writeIntIntoEEPROM(i, ResultRef[i]);
      }
      u8g.firstPage();
      do
      {
        u8g.setPrintPos(20, 29);
        u8g.print("CALIB COMPLETE");
      } while (u8g.nextPage());
      delay(800);
      calibration_process = 3;
    }
    if (calibration_process == 3)
    {
      check_Sensor();
      u8g.firstPage();
      do
      {
        u8g.setPrintPos(16, 14);
        u8g.print("CHECK SENSOR");
        u8g.setPrintPos(33, 29);
        printBinaryByte(bin_Sensor);
        u8g.setPrintPos(0, 59);
        u8g.print("1. BACK");
      } while (u8g.nextPage());
      delay(10);
    }
    if (calibration_process == 4)
    {
      calibration_mode = false;
      return;
    }
  }
}

void check_Sensor()
{
  read_Sensor();
  for (byte i = 0; i <= 7; i++)
  {
    bit_Sensor[i] = (Sensor_ADC_0[i] > ResultRef[i]) ? HIGH : LOW;
  }
  for (byte i = 0; i <= 7; i++)
  {
    bitWrite(bin_Sensor, i, bit_Sensor[i]);
  }
}
void read_Sensor()
{
  for (byte pin = 0; pin <= 7; pin++)
  {
    selectMultiplexerPin(pin);
    Sensor_ADC_0[pin] = analogRead(zInput);
  }
}
void selectMultiplexerPin(byte pin)
{
  for (int i = 0; i < 3; i++)
  {
    if (pin & (1 << i))
      digitalWrite(selectPins[i], LOW);
    else
      digitalWrite(selectPins[i], HIGH);
  }
}
void printBinaryByte(byte value)
{
  for (byte mask = 0x80; mask; mask >>= 1)
  {
    u8g.print((mask & value) ? '1' : '0');
  }
}

// ===================== EEPROM 16-bit (index*2) =====================
void writeIntIntoEEPROM(int index, int number)
{
  int address = index * 2;
  EEPROM.write(address, number >> 8);
  EEPROM.write(address + 1, number & 0xFF);
}
int readIntFromEEPROM(int index)
{
  int address = index * 2;
  return (EEPROM.read(address) << 8) | EEPROM.read(address + 1);
}

// ===================== CHECKPOINT MANAGEMENT =====================
void saveCheckpoints()
{
  int addr = CHECKPOINT_EEPROM_START;
  for (int i = 0; i < MAX_CHECKPOINTS; i++)
  {
    EEPROM.write(addr++, checkpoints[i].sensor_mask);
    EEPROM.write(addr++, checkpoints[i].duration_ms >> 8);
    EEPROM.write(addr++, checkpoints[i].duration_ms & 0xFF);
    EEPROM.write(addr++, checkpoints[i].action_type);
    EEPROM.write(addr++, checkpoints[i].enabled ? 1 : 0);
  }
}

void loadCheckpoints()
{
  int addr = CHECKPOINT_EEPROM_START;

  // Cek apakah data valid (contoh: cek jika action_type dalam range 0..4)
  bool valid = true;
  for (int i = 0; i < MAX_CHECKPOINTS; i++)
  {
    byte act_type = EEPROM.read(addr + (i * 5) + 3);
    if (act_type > 4)
    {
      valid = false;
      break;
    }
  }

  if (!valid)
  {
    initDefaultCheckpoints();
    saveCheckpoints();
    return;
  }

  for (int i = 0; i < MAX_CHECKPOINTS; i++)
  {
    checkpoints[i].sensor_mask = EEPROM.read(addr++);
    checkpoints[i].duration_ms = (EEPROM.read(addr++) << 8) | EEPROM.read(addr++);
    checkpoints[i].action_type = EEPROM.read(addr++);
    checkpoints[i].enabled = EEPROM.read(addr++) == 1;
  }
}

void initDefaultCheckpoints()
{
  // Checkpoint 0: Trigger sensor 0 (bit 0b00000001), belok kanan 300ms
  checkpoints[0].sensor_mask = 0b00000001; // sensor 0
  checkpoints[0].duration_ms = 300;
  checkpoints[0].action_type = 1; // kanan
  checkpoints[0].enabled = true;

  // Checkpoint 1: Trigger sensor 7 (bit 0b10000000), belok kiri 300ms
  checkpoints[1].sensor_mask = 0b10000000; // sensor 7
  checkpoints[1].duration_ms = 300;
  checkpoints[1].action_type = 0; // kiri
  checkpoints[1].enabled = true;

  // Checkpoint 2: Contoh berhenti, trigger sensor 3 dan 4 (0b00011000), stop 1000ms
  checkpoints[2].sensor_mask = 0b00011000;
  checkpoints[2].duration_ms = 1000;
  checkpoints[2].action_type = 2; // stop
  checkpoints[2].enabled = true;

  // Sisanya default disabled
  for (int i = 3; i < MAX_CHECKPOINTS; i++)
  {
    checkpoints[i].sensor_mask = 0b00000000;
    checkpoints[i].duration_ms = 300;
    checkpoints[i].action_type = 1;
    checkpoints[i].enabled = false;
  }
}
